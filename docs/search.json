{
  "articles": [
    {
      "path": "adjcurves.html",
      "title": "Adjusted survival curves",
      "author": [
        {
          "name": "André Moser, CTU Bern, University of Bern",
          "url": {}
        }
      ],
      "contents": "\n\nContents\nBackground\nExample\nKnowledge from the crystal ball\n\nAnalysis strategy\nDescriptive table\nUnadjusted Kaplan-Meier curve and Cox-modelling\nIPW modelling\n\nConclusion\nData simulation\n\nBackground\nUnadjusted Kaplan-Meier curves from observational data might be biased because of confounding (Cole and Hernán (2004)). This vignette introduces the concept of inverse probability (IP) weighted survival curves.\nExample\nWe consider a study population of 10,000 patients who received a medication. 60% of the patients were women. In men, a specific enzym was measured with a probability of 30%, whereas in women have a 5 times higher chance of having the enzym. Those with the enzym were more likely to receive the medication (with a probability of 75%), compared to those without the enyzm (probability of 50%).\nResearch question: What is the effect of the medication on death?\nStudy design: Cohort study\nOutcome of interest: Time to death or end of follow-up\nPredictor of interest: Medication\nConfounders: Sex, enzym\nThe used variables from the data are:\nVariable\nDefinition\nCoding\nfemale\nSex\n1=Women, 0=Men\nenzym\nMeasured enzym\n1=Present, 0=Not present\nmedi\nMedication\n1=Received, 0=Not received\ndeath\nDeath\n1=Death, 0=Alive\nfup\nFollow-up time\nNon-negative number\nKnowledge from the crystal ball\nBecause we simulated the data, we know that medication has no effect on mortality.\nAnalysis strategy\nIP weighting constructs weights which are equal to the probability of an individual’s treatment (here: receiving the medication) given observed covariates (here: sex and enzym) and creates pseudopopulations in which observed covariates are independent of treatment (i.e. no confounding) (Hernán and Robins (2022)).\n\n\n# Required packages\nlibrary(tidyverse)\nlibrary(survey)\nlibrary(survival)\nlibrary(gtsummary)\nlibrary(survminer)\n\n\n\n\n\n\nDescriptive table\nThe table below shows a descriptive summary of the study population, by medication.\n\n\ndata %>% tbl_summary(by=medi, label=list(medi ~ \"Medication\")) \n\n\n\nhtml {\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif;\n}\n\n#swynlxhket .gt_table {\n  display: table;\n  border-collapse: collapse;\n  margin-left: auto;\n  margin-right: auto;\n  color: #333333;\n  font-size: 16px;\n  font-weight: normal;\n  font-style: normal;\n  background-color: #FFFFFF;\n  width: auto;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #A8A8A8;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #A8A8A8;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n}\n\n#swynlxhket .gt_heading {\n  background-color: #FFFFFF;\n  text-align: center;\n  border-bottom-color: #FFFFFF;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#swynlxhket .gt_title {\n  color: #333333;\n  font-size: 125%;\n  font-weight: initial;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-color: #FFFFFF;\n  border-bottom-width: 0;\n}\n\n#swynlxhket .gt_subtitle {\n  color: #333333;\n  font-size: 85%;\n  font-weight: initial;\n  padding-top: 0;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-color: #FFFFFF;\n  border-top-width: 0;\n}\n\n#swynlxhket .gt_bottom_border {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#swynlxhket .gt_col_headings {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#swynlxhket .gt_col_heading {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  overflow-x: hidden;\n}\n\n#swynlxhket .gt_column_spanner_outer {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  padding-top: 0;\n  padding-bottom: 0;\n  padding-left: 4px;\n  padding-right: 4px;\n}\n\n#swynlxhket .gt_column_spanner_outer:first-child {\n  padding-left: 0;\n}\n\n#swynlxhket .gt_column_spanner_outer:last-child {\n  padding-right: 0;\n}\n\n#swynlxhket .gt_column_spanner {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 5px;\n  overflow-x: hidden;\n  display: inline-block;\n  width: 100%;\n}\n\n#swynlxhket .gt_group_heading {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#swynlxhket .gt_empty_group_heading {\n  padding: 0.5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#swynlxhket .gt_from_md > :first-child {\n  margin-top: 0;\n}\n\n#swynlxhket .gt_from_md > :last-child {\n  margin-bottom: 0;\n}\n\n#swynlxhket .gt_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  margin: 10px;\n  border-top-style: solid;\n  border-top-width: 1px;\n  border-top-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  overflow-x: hidden;\n}\n\n#swynlxhket .gt_stub {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#swynlxhket .gt_stub_row_group {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n  vertical-align: top;\n}\n\n#swynlxhket .gt_row_group_first td {\n  border-top-width: 2px;\n}\n\n#swynlxhket .gt_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#swynlxhket .gt_first_summary_row {\n  border-top-style: solid;\n  border-top-color: #D3D3D3;\n}\n\n#swynlxhket .gt_first_summary_row.thick {\n  border-top-width: 2px;\n}\n\n#swynlxhket .gt_last_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#swynlxhket .gt_grand_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#swynlxhket .gt_first_grand_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: double;\n  border-top-width: 6px;\n  border-top-color: #D3D3D3;\n}\n\n#swynlxhket .gt_striped {\n  background-color: rgba(128, 128, 128, 0.05);\n}\n\n#swynlxhket .gt_table_body {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#swynlxhket .gt_footnotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#swynlxhket .gt_footnote {\n  margin: 0px;\n  font-size: 90%;\n  padding-left: 4px;\n  padding-right: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#swynlxhket .gt_sourcenotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#swynlxhket .gt_sourcenote {\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#swynlxhket .gt_left {\n  text-align: left;\n}\n\n#swynlxhket .gt_center {\n  text-align: center;\n}\n\n#swynlxhket .gt_right {\n  text-align: right;\n  font-variant-numeric: tabular-nums;\n}\n\n#swynlxhket .gt_font_normal {\n  font-weight: normal;\n}\n\n#swynlxhket .gt_font_bold {\n  font-weight: bold;\n}\n\n#swynlxhket .gt_font_italic {\n  font-style: italic;\n}\n\n#swynlxhket .gt_super {\n  font-size: 65%;\n}\n\n#swynlxhket .gt_footnote_marks {\n  font-style: italic;\n  font-weight: normal;\n  font-size: 75%;\n  vertical-align: 0.4em;\n}\n\n#swynlxhket .gt_asterisk {\n  font-size: 100%;\n  vertical-align: 0;\n}\n\n#swynlxhket .gt_slash_mark {\n  font-size: 0.7em;\n  line-height: 0.7em;\n  vertical-align: 0.15em;\n}\n\n#swynlxhket .gt_fraction_numerator {\n  font-size: 0.6em;\n  line-height: 0.6em;\n  vertical-align: 0.45em;\n}\n\n#swynlxhket .gt_fraction_denominator {\n  font-size: 0.6em;\n  line-height: 0.6em;\n  vertical-align: -0.05em;\n}\nCharacteristic\n      0, N = 3,6391\n      1, N = 6,3611\n    fup\n8 (3, 17)\n6 (2, 13)death\n1,225 (34%)\n3,064 (48%)enzym\n1,321 (36%)\n3,973 (62%)female\n1,972 (54%)\n4,062 (64%)1 Median (IQR); n (%)\n    \n\nUnadjusted Kaplan-Meier curve and Cox-modelling\nA naive (unadjusted) survival analysis of the data reveals the following Kaplan-Meier plot. We conclude that the medication has an effect on survival.\n\n\nmod <- survfit(Surv(fup, death)~medi, data=data)\nggsurvplot(mod, data=data, palette=c(\"#CC0000\", \"black\"), censor=F)\n\n\n\n\n\n\nmod_cox_unadjusted <- coxph(Surv(fup, death) ~ medi, data = data)\nmod_cox_unadjusted\n\n\nCall:\ncoxph(formula = Surv(fup, death) ~ medi, data = data)\n\n        coef exp(coef) se(coef)     z      p\nmedi 0.50613   1.65887  0.03385 14.95 <2e-16\n\nLikelihood ratio test=238.4  on 1 df, p=< 2.2e-16\nn= 10000, number of events= 4289 \n\nAn unadjusted Cox proportional hazard model shows that patients with medication have 1.7 higher hazard of death compared to those without medication.\n\n\nmod_cox_adjusted <- coxph(Surv(fup, death) ~ medi+enzym+female, data = data)\nmod_cox_adjusted\n\n\nCall:\ncoxph(formula = Surv(fup, death) ~ medi + enzym + female, data = data)\n\n           coef exp(coef) se(coef)      z      p\nmedi    0.01610   1.01623  0.03445  0.467  0.640\nenzym   2.37236  10.72265  0.04703 50.441 <2e-16\nfemale  0.07087   1.07344  0.03552  1.995  0.046\n\nLikelihood ratio test=4221  on 3 df, p=< 2.2e-16\nn= 10000, number of events= 4289 \n\nWhat happens if we adjust for enzym and sex? Then the effect of the medication on death vanish (hazard ratio=1.02).\nIPW modelling\nAn IPW modelling approach construct treatment weights (here medication) given known covariates (here sex and enzym) using a logistic regression model.\n\n\n# IPW denominator\nmod <- glm(medi ~ female+enzym, data=data, family=binomial())\n\ndata$ipw <- NA\n# Probabilty of treatment\ndata$ipw <- predict(mod, data=data, type=\"response\")\n# Probabilty of non-treatment\ndata$ipw[data$medi==0] <- 1-predict(mod, data=data, type=\"response\")[data$medi==0]\n\n\n\nWe construct stabilized weights, since they can provide narrower confidence intervals (Hernán and Robins (2022)).\n\n\n# Stabilized weights\nmod0 <- glm(medi ~ 1, data=data, family=binomial())\ndata$ipw0 <- predict(mod0, data=data, type=\"response\")\ndata$ipw0[data$medi==0] <- 1-predict(mod0, data=data, type=\"response\")[data$medi==0]\ndata$ipw <- data$ipw0/data$ipw\n\n\n\nAn IPW adjusted Kaplan-Meier curve reveals that medication has no effect on survival:\n\n\n# Set survey design\nsvy_design <- svydesign(id=~1, weights=~ipw, data=data)\n\n# IPW adjusted Kaplan-Meier\nkm_fit <- svykm(Surv(fup, death) ~ medi, design=svy_design)\n\nkm_df <- data.frame(time=km_fit$`1`$time, surv=km_fit$`1`$surv, strata=\"medi=1\")\nkm_df <- bind_rows(km_df, data.frame(time=km_fit$`0`$time, surv=km_fit$`0`$surv, strata=\"medi=0\"))\nggsurvplot_df(km_df, palette=c(\"#CC0000\", \"black\"), censor=F)\n\n\n\n\n\n\nmod_cox_ipw_adjusted <- svycoxph(Surv(fup, death) ~ medi, design=svy_design)\nsummary(mod_cox_ipw_adjusted)\n\n\nIndependent Sampling design (with replacement)\nsvydesign(id = ~1, weights = ~ipw, data = data)\nCall:\nsvycoxph(formula = Surv(fup, death) ~ medi, design = svy_design)\n\n  n= 10000, number of events= 4289 \n\n        coef exp(coef) se(coef) robust se     z Pr(>|z|)\nmedi 0.01669   1.01683  0.03192   0.03323 0.502    0.616\n\n     exp(coef) exp(-coef) lower .95 upper .95\nmedi     1.017     0.9835    0.9527     1.085\n\nConcordance= 0.502  (se = 0.004 )\nLikelihood ratio test= NA  on 1 df,   p=NA\nWald test            = 0.25  on 1 df,   p=0.6\nScore (logrank) test = NA  on 1 df,   p=NA\n\n  (Note: the likelihood ratio and score tests assume independence of\n     observations within a cluster, the Wald and robust score tests do not).\n\nThis is confirmed by an IPW adjusted Cox regression model (hazard ratio=1.02).\nConclusion\nUnadjusted Kaplan-Meier curves from observational data might be biased because of confounding. IPW adjusted survival curves account for confounding by constructing weights which are proportional to the probability of treatment given known covariates. An advantage of IPW adjusted Kaplan-Meier curves is that they provide marginal survival estimates, in contrast to stratified plots (Cole and Hernán (2004)).\nData simulation\n\n\nset.seed(1)\nn <- 10000\n\n# 60% percent women\nfemale <- rbinom(n, 1, 0.6)\n# Men has the enzym with a prob of 0.3; women have\n# a 5 times higher chance of having the enzym\nenzym <- ifelse(runif(n) < plogis(qlogis(0.3)+log(5)*female), 1, 0)\n# Those with enzym receive medication with prob 0.75\nmedi <- ifelse(runif(n) < plogis(log(3)*enzym), 1, 0)\n# Hazard of dying: HR=10 of those with enyzm; No effect for medication\nhaz <- 0.01*exp(log(10)*enzym)\n# Time to death\ntime_to_death <- -log(runif(n))/haz\n# Censoring time: Mean duration 20 days\ncensored <- rweibull(n, 1, 20)\n# Follow-up time\nfup <- pmin(time_to_death, censored)\n# Death\ndeath <- ifelse(time_to_death<=censored, 1, 0)\n# Data\ndata <- data.frame(fup, death, medi, enzym, female)\n\n\n\n\n\n\nCole, Stephen R., and Miguel A. Hernán. 2004. “Adjusted Survival Curves with Inverse Probability Weights.” Computer Methods and Programs in Biomedicine 75 (1): 45–49. https://doi.org/10.1016/j.cmpb.2003.10.004.\n\n\nHernán, MA, and JM Robins. 2022. Causal Inference: What If. Boca Raton: Chapman & Hall/CRC.\n\n\n\n\n",
      "last_modified": "2022-05-03T11:50:15+02:00"
    },
    {
      "path": "hierachicalpriors.html",
      "title": "Comparison of hierachical priors in INLA and STAN",
      "author": [],
      "contents": "\n\n\n\nBackground\nWe compare results using different hierarchical priors from INLA and STAN. Specifically, we use default priors and priors suggested by Andrew Gelman (Gelman (2006)).\nHierarchical data\nWe assume a hierarchical model \\[\nlogit(y_{ij})=\\alpha+\\beta^\\top\\mathbf{X}+b_i, \\quad j\\leq J, i\\leq n \n\\] with \\(b_i \\sim N(0, \\sigma^2)\\).\nPriors\nJeffrey’s prior for \\(\\sigma^k\\) is \\(f(\\sigma^k) \\propto 1/\\sigma^k\\), \\(k>0\\). For, e.g., \\(k=2\\) this is an improper prior distribution because \\(\\int_0^\\infty x^{-2}dx=-x^{-2}|_0^\\infty=\\infty\\).\nBy change-of-variables we get that \\(\\theta=log(\\sigma)\\)\n\\[\nf_{\\theta}(\\theta)=f(\\sigma)\\{h^{-1}(\\theta)\\} \\cdot \\vert\\frac{dh^{-1}(\\theta)}{d\\theta} \\vert=(1/exp(\\sigma))\\cdot exp(\\sigma)=1,\n\\]\ni.e setting a \\(f(\\sigma) \\propto 1/\\sigma\\) is equivalent to \\(f(log(\\sigma)) \\propto 1\\).\nAggregated binomial data\n\n\nlibrary(lme4)\nhead(cbpp)\n\n\n  herd incidence size period\n1    1         2   14      1\n2    1         3   12      2\n3    1         4    9      3\n4    1         0    5      4\n5    2         3   22      1\n6    2         1   18      2\n\nFrequentist glmer model\nPeriod as categorical variable\n\n\ngm1 <- glmer(cbind(incidence, size - incidence) ~ factor(period) + (1 | herd), \n             data = cbpp, family = binomial)\nsummary(gm1)\n\n\nGeneralized linear mixed model fit by maximum likelihood (Laplace\n  Approximation) [glmerMod]\n Family: binomial  ( logit )\nFormula: \ncbind(incidence, size - incidence) ~ factor(period) + (1 | herd)\n   Data: cbpp\n\n     AIC      BIC   logLik deviance df.resid \n   194.1    204.2    -92.0    184.1       51 \n\nScaled residuals: \n    Min      1Q  Median      3Q     Max \n-2.3816 -0.7889 -0.2026  0.5142  2.8791 \n\nRandom effects:\n Groups Name        Variance Std.Dev.\n herd   (Intercept) 0.4123   0.6421  \nNumber of obs: 56, groups:  herd, 15\n\nFixed effects:\n                Estimate Std. Error z value Pr(>|z|)    \n(Intercept)      -1.3983     0.2312  -6.048 1.47e-09 ***\nfactor(period)2  -0.9919     0.3032  -3.272 0.001068 ** \nfactor(period)3  -1.1282     0.3228  -3.495 0.000474 ***\nfactor(period)4  -1.5797     0.4220  -3.743 0.000182 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nCorrelation of Fixed Effects:\n            (Intr) fct()2 fct()3\nfactr(prd)2 -0.363              \nfactr(prd)3 -0.340  0.280       \nfactr(prd)4 -0.260  0.213  0.198\n\nSTAN\nSTAN model with prior \\(p(\\sigma)=Halfcauchy(0, 25)\\).\n\n\n# library(brms)\n# \n# b12.2 <- \n#   brm(data = cbpp, family = binomial,\n#       incidence | trials(size) ~ 1 + (1 | herd),\n#       prior = c(prior(normal(0, 1000), class = Intercept),\n#                 prior(cauchy(0, 25), class = sd)),\n#       iter = 4000, warmup = 1000, chains = 4, cores = 4,\n#       seed = 12)\n\n### Get contrasts for period\nperiod_factors <- model.matrix(incidence ~ factor(period), data=cbpp)\n\nstan_data <- list(N = nrow(cbpp), G=length(unique(cbpp$herd)), y = cbpp$incidence, \n                  N_i=cbpp$size, g=as.numeric(cbpp$herd), K=ncol(period_factors[,-1]), X=period_factors[,-1])\n\n\nwrite(\"\ndata {\n  int N; // number of obs\n  int G; // number of groups\n  int K; // number of predictors\n\n  int y[N];\n  int N_i[N];\n  int g[N]; // map obs to groups\n  row_vector[K] X[N];\n}\n\nparameters {\n  real a_g[G];\n  real intercept; // improper uniform prior (-inf, inf) \n  vector[K] beta; // improper uniform prior (-inf, inf) \n  real <lower=0> sigma;\n}\n\nmodel {\n    vector[N] p;\n    for (i in 1:N) {\n        p[i] = inv_logit(intercept+X[i]*beta+a_g[g[i]]);\n    }\n    y ~ binomial(N_i, p);\n    a_g ~ normal(0, sigma);\n    intercept ~ normal(0, 1000); // same as INLA\n    sigma ~ cauchy(0, 25);\n}\n\"\n, file=paste0(pp, \"/04_prepared_data/\", \"StanPrior1.stan\"))\n\n\nstanfile <- paste0(pp, \"/04_prepared_data/\", \"StanPrior1.stan\")\n\nfit <- stan(file = stanfile, data = stan_data, warmup = 500, iter = 5000, chains = 4, \n            cores = 6, thin = 1, seed=14749823)\n\n\n# Get posteriors\nposteriors <- as.data.frame(extract(fit))\n\nplot_data <- data.frame(x=density(posteriors$sigma)$x, y=density(posteriors$sigma)$y, type=\"posterior\")\nx_prior <- seq(0,max(posteriors$sigma), 0.01)\ncauchy_scale <- 25\nplot_data <- bind_rows(plot_data, data.frame(x=x_prior, y=dcauchy(x_prior, 0, cauchy_scale), type=\"prior\"))\n\n# Plot posterior distribution of SD of hyperparameter\nggplot(plot_data, aes(x=x, y=y, colour=type, linetype=type))+geom_line()+theme_bw()+scale_color_brewer(\"\", palette=\"Dark2\")+guides(linetype=\"none\")+ylab(\"Density\")+xlab(\"Hyperparameter sigma\")\n\n\n\n# 88% credible intervals\nalpha <- 0.12\nquantile(posteriors$sigma, probs=c(alpha/2, 1-alpha/2))\n\n\n       6%       94% \n0.4657261 1.1650252 \n\n# P(SD<=q)=0.12\nquantile(posteriors$sigma, probs=alpha)\n\n\n      12% \n0.5235954 \n\n# Probability that hyperparameter!=0\nsum(posteriors$sigma>0)/length(posteriors$sigma)\n\n\n[1] 1\n\n\n\nwrite(\"\ndata {\n  int N; // number of obs\n  int G; // number of groups\n  int K; // number of predictors\n\n  int y[N];\n  int N_i[N];\n  int g[N]; // map obs to groups\n  row_vector[K] X[N];\n}\n\nparameters {\n  real a_g[G];\n  real intercept; // improper uniform prior (-inf, inf) \n  vector[K] beta; // improper uniform prior (-inf, inf) \n  real <lower=0> sigma; // improper uniform prior (-inf, inf) \n}\n\nmodel {\n    vector[N] p;\n    for (i in 1:N) {\n        p[i] = inv_logit(intercept+X[i]*beta+a_g[g[i]]);\n    }\n    y ~ binomial(N_i, p);\n    a_g ~ normal(0, sigma);\n    intercept ~ normal(0, 1000); // same as INLA\n}\n\"\n, file=paste0(pp, \"/04_prepared_data/\", \"StanPrior2.stan\"))\n\n\nstanfile <- paste0(pp, \"/04_prepared_data/\", \"StanPrior2.stan\")\n\nfit2 <- stan(file = stanfile, data = stan_data, warmup = 500, iter = 5000, chains = 4, \n            cores = 6, thin = 1, seed=14749823)\n\n\n# Get posteriors\nposteriors2 <- as.data.frame(extract(fit2))\n\n\n\n\n\nwrite(\"\ndata {\n  int N; // number of obs\n  int G; // number of groups\n  int K; // number of predictors\n\n  int y[N];\n  int N_i[N];\n  int g[N]; // map obs to groups\n  row_vector[K] X[N];\n}\n\nparameters {\n  real a_g[G];\n  real intercept; // improper uniform prior (-inf, inf) \n  vector[K] beta; // improper uniform prior (-inf, inf) \n  real <lower=0> sigma;\n}\n\nmodel {\n    vector[N] p;\n    for (i in 1:N) {\n        p[i] = inv_logit(intercept+X[i]*beta+a_g[g[i]]);\n    }\n    y ~ binomial(N_i, p);\n    a_g ~ normal(0, sigma);\n    intercept ~ normal(0, 1000); // same as INLA\n    sigma ~ inv_gamma(1, 0.00005);\n}\n\"\n, file=paste0(pp, \"/04_prepared_data/\", \"StanPrior3.stan\"))\n\n\nstanfile <- paste0(pp, \"/04_prepared_data/\", \"StanPrior3.stan\")\n\nfit3 <- stan(file = stanfile, data = stan_data, warmup = 500, iter = 5000, chains = 4, \n            cores = 6, thin = 1, seed=14749823)\n\n\n# Get posteriors\nposteriors3 <- as.data.frame(extract(fit3))\n\n\n\n\n\nwrite(\"\ndata {\n  int N; // number of obs\n  int G; // number of groups\n  int K; // number of predictors\n\n  int y[N];\n  int N_i[N];\n  int g[N]; // map obs to groups\n  row_vector[K] X[N];\n}\n\nparameters {\n  real a_g[G];\n  real intercept; // improper uniform prior (-inf, inf) \n  vector[K] beta; // improper uniform prior (-inf, inf) \n  real <lower=0> sigma;\n}\n\nmodel {\n    vector[N] p;\n    for (i in 1:N) {\n        p[i] = inv_logit(intercept+X[i]*beta+a_g[g[i]]);\n    }\n    y ~ binomial(N_i, p);\n    a_g ~ normal(0, sigma);\n    intercept ~ normal(0, 1000); // same as INLA\n    sigma ~ cauchy(0, 0.1);\n}\n\"\n, file=paste0(pp, \"/04_prepared_data/\", \"StanPrior4.stan\"))\n\n\nstanfile <- paste0(pp, \"/04_prepared_data/\", \"StanPrior4.stan\")\n\nfit4 <- stan(file = stanfile, data = stan_data, warmup = 500, iter = 5000, chains = 4, \n            cores = 6, thin = 1, seed=14749823)\n\n\n# Get posteriors\nposteriors4 <- as.data.frame(extract(fit4))\n\n\n\nINLA\nNote: INLA is internally parametrised on the log precision. When \\(log(\\tau)\\) is logGamma(a,b) distributed then (i.e. the log precision) then \\(\\tau\\) is Gamma(a,b) distributed with density \\[\np(\\tau)=\\frac{b^a}{\\Gamma(a)}\\tau^{a-1}exp(-b\\tau),\n\\] where \\(b\\) is the inverse scale parameter (see https://inla.r-inla-download.org/r-inla.org/doc/prior/prior-loggamma.pdf). When \\(\\tau \\sim Gamma(a,s)\\) then \\(\\tau^{-1} \\sim InvGamma(a,s)\\).\nNote: The base R functions (dgamma, pgamma, qgamma and rgamma) are parametrised as \\[\np(\\tau)=\\frac{1}{b^a\\Gamma(a)}\\tau^{a-1}exp(-s\\tau),\n\\] where \\(s=1/b\\) is the rate parameter.\n\n\nlibrary(INLA)\nlibrary(brinla)\n\nHC.prior  = \"expression:\n  sigma = exp(-theta/2);\n  gamma = 25;\n  log_dens = log(2) - log(pi) - log(gamma);\n  log_dens = log_dens - log(1 + (sigma / gamma)^2);\n  log_dens = log_dens - log(2) - theta / 2;\n  return(log_dens);\n\"\n\nHC.prior2  = \"expression:\n  sigma = exp(-theta/2);\n  gamma = 0.1;\n  log_dens = log(2) - log(pi) - log(gamma);\n  log_dens = log_dens - log(1 + (sigma / gamma)^2);\n  log_dens = log_dens - log(2) - theta / 2;\n  return(log_dens);\n\"\n\n# Note: UN.prior is unrestricted!\nUN.prior = \"expression:\n  log_dens = 0 - log(2) - theta / 2;\n  return(log_dens);\n\"\n\nprior.list = list(\n  prior1 = list(prec = list(prior = HC.prior)),\n  prior2 = list(prec = list(prior = UN.prior)),\n  default = list(prec = list(prior = \"loggamma\", param = c(1, 0.00005))),\n  prior3 = list(prec = list(prior = HC.prior2))\n\n) \n\nintercept_fixed_prio <- list(mean.intercept=0, prec.intercept=1/1000)\n\ninla_models <- lapply(prior.list, function(tau.prior) {\n  inla(incidence ~ factor(period)+f(herd, model=\"iid\", hyper=tau.prior), data=cbpp, family=\"binomial\", control.predictor = list(link=1, compute = TRUE), control.compute = list(dic=T, cpo=T, waic=T), control.fixed=intercept_fixed_prio, Ntrials=size)\n})\n\n\n\n\n\nresults <- c()\nresults <- bind_rows(results, data.frame(bri.hyper.sd(inla_models$prior1$marginals.hyperpar[[1]]), type=\"INLA: HC(0, 25)\"))\nresults <- bind_rows(results, data.frame(bri.hyper.sd(inla_models$prior2$marginals.hyperpar[[1]]), type=\"INLA: Improper uniform\"))\nresults <- bind_rows(results, data.frame(bri.hyper.sd(inla_models$default$marginals.hyperpar[[1]]), type=\"INLA: Gamma(1, 0.00005)\"))\nresults <- bind_rows(results, data.frame(bri.hyper.sd(inla_models$prior3$marginals.hyperpar[[1]]), type=\"INLA: HC(0, 0.1)\"))\nresults <- bind_rows(results, data.frame(x=density(posteriors$sigma)$x, y=density(posteriors$sigma)$y, type=\"STAN: HC(0, 25)\"))\nresults <- bind_rows(results, data.frame(x=density(posteriors2$sigma)$x, y=density(posteriors2$sigma)$y, type=\"STAN: Improper uniform\"))\nresults <- bind_rows(results, data.frame(x=density(posteriors3$sigma)$x, y=density(posteriors3$sigma)$y, type=\"STAN: Gamma(1, 0.00005)\"))\nresults <- bind_rows(results, data.frame(x=density(posteriors4$sigma)$x, y=density(posteriors4$sigma)$y, type=\"STAN: HC(0, 0.1)\"))\n\nggplot(results, aes(x=x, y=y, colour=type))+geom_line()+coord_cartesian(ylim=c(0,3))+facet_wrap(~type)+geom_vline(xintercept=sqrt(summary(gm1)$varcor[[1]]), linetype=\"dashed\")+labs(caption=\"Dashed vertical line: Estimated SD of hyperparameter from GLMER\")+theme_bw()+theme(legend.position = \"bottom\")+scale_color_brewer(\"\", palette=\"Dark2\")\n\n\n\n\n\n\n\nGelman, Andrew. 2006. “Prior distributions for variance parameters in hierarchical models (comment on article by Browne and Draper).” Bayesian Analysis 1 (3): 515–34. https://doi.org/10.1214/06-BA117A.\n\n\n\n\n",
      "last_modified": "2022-04-28T14:59:26+02:00"
    },
    {
      "path": "immortal.html",
      "title": "Immortal time bias",
      "author": [],
      "contents": "\nBackground\nR Core Team (2021) said…\nExample(s)\nConclusion\nReferences\n\n\n\nR Core Team. 2021. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/.\n\n\n\n\n",
      "last_modified": "2022-04-28T11:36:18+02:00"
    },
    {
      "path": "index.html",
      "title": "Vignettes",
      "description": "",
      "author": [],
      "contents": "\nClick on the upper right button for topic selection.\n\n\n\n",
      "last_modified": "2022-05-03T12:05:14+02:00"
    }
  ],
  "collections": []
}
